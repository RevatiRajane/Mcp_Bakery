Help on module mcp.types in mcp:

NNAAMMEE
    mcp.types

CCLLAASSSSEESS
    pydantic.main.BaseModel(builtins.object)
        Annotations
        AudioContent
        ClientCapabilities
        Completion
        CompletionArgument
        EmbeddedResource
        ErrorData
        ImageContent
        Implementation
        JSONRPCError
        JSONRPCResponse
        LoggingCapability
        ModelHint
        ModelPreferences
        Notification(pydantic.main.BaseModel, typing.Generic)
            Notification[CancelledNotificationParams, Literal['notifications/cancelled']]
                CancelledNotification
            Notification[LoggingMessageNotificationParams, Literal['notifications/message']]
                LoggingMessageNotification
            Notification[ProgressNotificationParams, Literal['notifications/progress']]
                ProgressNotification
            Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]
                ResourceUpdatedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']]
                InitializedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']]
                PromptListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']]
                ResourceListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']]
                RootsListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']]
                ToolListChangedNotification
            Notification[Union[dict[str, Any], NoneType], str]
                JSONRPCNotification
        NotificationParams
            CancelledNotificationParams
            LoggingMessageNotificationParams
            ProgressNotificationParams
            ResourceUpdatedNotificationParams
        Prompt
        PromptArgument
        PromptMessage
        PromptReference
        PromptsCapability
        Request(pydantic.main.BaseModel, typing.Generic)
            Request[CallToolRequestParams, Literal['tools/call']]
                CallToolRequest
            Request[CompleteRequestParams, Literal['completion/complete']]
                CompleteRequest
            Request[CreateMessageRequestParams, Literal['sampling/createMessage']]
                CreateMessageRequest
            Request[GetPromptRequestParams, Literal['prompts/get']]
                GetPromptRequest
            Request[InitializeRequestParams, Literal['initialize']]
                InitializeRequest
            Request[ReadResourceRequestParams, Literal['resources/read']]
                ReadResourceRequest
            Request[SetLevelRequestParams, Literal['logging/setLevel']]
                SetLevelRequest
            Request[SubscribeRequestParams, Literal['resources/subscribe']]
                SubscribeRequest
            Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
                PaginatedRequest(Request[Union[PaginatedRequestParams, NoneType], ~MethodT], typing.Generic)
                    PaginatedRequest[Literal['prompts/list']]
                        ListPromptsRequest
                    PaginatedRequest[Literal['resources/list']]
                        ListResourcesRequest
                    PaginatedRequest[Literal['resources/templates/list']]
                        ListResourceTemplatesRequest
                    PaginatedRequest[Literal['tools/list']]
                        ListToolsRequest
            Request[Union[RequestParams, NoneType], Literal['ping']]
                PingRequest
            Request[Union[RequestParams, NoneType], Literal['roots/list']]
                ListRootsRequest
            Request[Union[dict[str, Any], NoneType], str]
                JSONRPCRequest
            Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]
                UnsubscribeRequest
        RequestParams
            CallToolRequestParams
            CompleteRequestParams
            CreateMessageRequestParams
            GetPromptRequestParams
            InitializeRequestParams
            PaginatedRequestParams
            ReadResourceRequestParams
            SetLevelRequestParams
            SubscribeRequestParams
            UnsubscribeRequestParams
        Resource
        ResourceContents
            BlobResourceContents
            TextResourceContents
        ResourceReference
        ResourceTemplate
        ResourcesCapability
        Result
            CallToolResult
            CompleteResult
            CreateMessageResult
            EmptyResult
            GetPromptResult
            InitializeResult
            ListRootsResult
            PaginatedResult
                ListPromptsResult
                ListResourceTemplatesResult
                ListResourcesResult
                ListToolsResult
            ReadResourceResult
        Root
        RootsCapability
        SamplingCapability
        SamplingMessage
        ServerCapabilities
        TextContent
        Tool
        ToolAnnotations
        ToolsCapability
    pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]](pydantic.root_model.RootModel)
        ClientNotification
    pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]](pydantic.root_model.RootModel)
        ServerNotification
    pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]](pydantic.root_model.RootModel)
        ClientResult
    pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]](pydantic.root_model.RootModel)
        ServerResult
    pydantic.root_model.RootModel[Union[JSONRPCRequest, JSONRPCNotification, JSONRPCResponse, JSONRPCError]](pydantic.root_model.RootModel)
        JSONRPCMessage
    pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]](pydantic.root_model.RootModel)
        ServerRequest
    pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]](pydantic.root_model.RootModel)
        ClientRequest
    typing.Generic(builtins.object)
        Notification(pydantic.main.BaseModel, typing.Generic)
            Notification[CancelledNotificationParams, Literal['notifications/cancelled']]
                CancelledNotification
            Notification[LoggingMessageNotificationParams, Literal['notifications/message']]
                LoggingMessageNotification
            Notification[ProgressNotificationParams, Literal['notifications/progress']]
                ProgressNotification
            Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]
                ResourceUpdatedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']]
                InitializedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']]
                PromptListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']]
                ResourceListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']]
                RootsListChangedNotification
            Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']]
                ToolListChangedNotification
            Notification[Union[dict[str, Any], NoneType], str]
                JSONRPCNotification
        Request(pydantic.main.BaseModel, typing.Generic)
            Request[CallToolRequestParams, Literal['tools/call']]
                CallToolRequest
            Request[CompleteRequestParams, Literal['completion/complete']]
                CompleteRequest
            Request[CreateMessageRequestParams, Literal['sampling/createMessage']]
                CreateMessageRequest
            Request[GetPromptRequestParams, Literal['prompts/get']]
                GetPromptRequest
            Request[InitializeRequestParams, Literal['initialize']]
                InitializeRequest
            Request[ReadResourceRequestParams, Literal['resources/read']]
                ReadResourceRequest
            Request[SetLevelRequestParams, Literal['logging/setLevel']]
                SetLevelRequest
            Request[SubscribeRequestParams, Literal['resources/subscribe']]
                SubscribeRequest
            Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
                PaginatedRequest(Request[Union[PaginatedRequestParams, NoneType], ~MethodT], typing.Generic)
                    PaginatedRequest[Literal['prompts/list']]
                        ListPromptsRequest
                    PaginatedRequest[Literal['resources/list']]
                        ListResourcesRequest
                    PaginatedRequest[Literal['resources/templates/list']]
                        ListResourceTemplatesRequest
                    PaginatedRequest[Literal['tools/list']]
                        ListToolsRequest
            Request[Union[RequestParams, NoneType], Literal['ping']]
                PingRequest
            Request[Union[RequestParams, NoneType], Literal['roots/list']]
                ListRootsRequest
            Request[Union[dict[str, Any], NoneType], str]
                JSONRPCRequest
            Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]
                UnsubscribeRequest
    
    class AAnnnnoottaattiioonnss(pydantic.main.BaseModel)
     |  Annotations(*, audience: list[typing.Literal['user', 'assistant']] | None = None, priority: Optional[Annotated[float, FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0.0), Le(le=1.0)])]] = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Annotations
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'audience': list[typing.Literal['user', 'assistant'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Annotations'>, 'c...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'audience': FieldInfo(annotation=Union[list[Lit...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Annotations", validato...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, audience: list[typing.Literal['us...e(l...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'audience': FieldInfo(annotation=Union[list[Literal['u...
    
    class AAuuddiiooCCoonntteenntt(pydantic.main.BaseModel)
     |  AudioContent(*, type: Literal['audio'], data: str, mimeType: str, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  Audio content for a message.
     |  
     |  Method resolution order:
     |      AudioContent
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'data'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.AudioContent'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="AudioContent", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['audio'], data: str...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class BBlloobbRReessoouurrcceeCCoonntteennttss(ResourceContents)
     |  BlobResourceContents(*, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], mimeType: str | None = None, blob: str, **extra_data: Any) -> None
     |  
     |  Binary contents of a resource.
     |  
     |  Method resolution order:
     |      BlobResourceContents
     |      ResourceContents
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'blob': <class 'str'>}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.BlobResourceConte...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'blob': FieldInfo(annotation=str, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="BlobResourceContents",...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uri: typing.Annotated[pydantic.ne...ne ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ResourceContents:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'blob': FieldInfo(annotation=str, required=True), 'mim...
    
    class CCaallllTToooollRReeqquueesstt(Request[CallToolRequestParams, Literal['tools/call']])
     |  CallToolRequest(*, method: Literal['tools/call'], params: mcp.types.CallToolRequestParams, **extra_data: Any) -> None
     |  
     |  Used by the client to invoke a tool provided by the server.
     |  
     |  Method resolution order:
     |      CallToolRequest
     |      Request[CallToolRequestParams, Literal['tools/call']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['tools/call'], 'params': <...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CallToolRequest'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['tools/c...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CallToolRequest", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['tools/call'], pa...all...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['tools/call'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class CCaallllTToooollRReeqquueessttPPaarraammss(RequestParams)
     |  CallToolRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, name: str, arguments: dict[str, typing.Any] | None = None, **extra_data: Any) -> None
     |  
     |  Parameters for calling a tool.
     |  
     |  Method resolution order:
     |      CallToolRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'arguments': dict[str, typing.Any] | None, 'name': ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CallToolRequestPa...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'arguments': FieldInfo(annotation=Union[dict[st...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CallToolRequestParams"...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me...g.A...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'arguments': FieldInfo(annotation=Union[dict[str, Any]...
    
    class CCaallllTToooollRReessuulltt(Result)
     |  CallToolResult(*, _meta: dict[str, typing.Any] | None = None, content: list[mcp.types.TextContent | mcp.types.ImageContent | mcp.types.AudioContent | mcp.types.EmbeddedResource], isError: bool = False, **extra_data: Any) -> None
     |  
     |  The server's response to a tool call.
     |  
     |  Method resolution order:
     |      CallToolResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'content': list[mcp.types.TextContent | mcp.types.I...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CallToolResult'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'content': FieldInfo(annotation=list[Union[Text...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CallToolResult", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...sEr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'content': FieldInfo(annotation=list[Union[TextContent...
    
    class CCaanncceelllleeddNNoottiiffiiccaattiioonn(Notification[CancelledNotificationParams, Literal['notifications/cancelled']])
     |  CancelledNotification(*, method: Literal['notifications/cancelled'], params: mcp.types.CancelledNotificationParams, **extra_data: Any) -> None
     |  
     |  This notification can be sent by either side to indicate that it is canceling a
     |  previously-issued request.
     |  
     |  Method resolution order:
     |      CancelledNotification
     |      Notification[CancelledNotificationParams, Literal['notifications/cancelled']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/cancelled']...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CancelledNotifica...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CancelledNotification"...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/ca...edN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class CCaanncceelllleeddNNoottiiffiiccaattiioonnPPaarraammss(NotificationParams)
     |  CancelledNotificationParams(*, _meta: mcp.types.NotificationParams.Meta | None = None, requestId: typing.Annotated[int | str, _PydanticGeneralMetadata(union_mode='left_to_right')], reason: str | None = None, **extra_data: Any) -> None
     |  
     |  Parameters for cancellation notifications.
     |  
     |  Method resolution order:
     |      CancelledNotificationParams
     |      NotificationParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'reason': str | None, 'requestId': typing.Annotated...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CancelledNotifica...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[Notification...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CancelledNotificationP...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.NotificationPara...n: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NotificationParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NotificationParams:
     |  
     |  MMeettaa = <class 'mcp.types.NotificationParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[NotificationParams....
    
    class CClliieennttCCaappaabbiilliittiieess(pydantic.main.BaseModel)
     |  ClientCapabilities(*, experimental: dict[str, dict[str, typing.Any]] | None = None, sampling: mcp.types.SamplingCapability | None = None, roots: mcp.types.RootsCapability | None = None, **extra_data: Any) -> None
     |  
     |  Capabilities a client may support.
     |  
     |  Method resolution order:
     |      ClientCapabilities
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'experimental': dict[str, dict[str, typing.Any]] | ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ClientCapabilitie...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'experimental': FieldInfo(annotation=Union[dict...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ClientCapabilities", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, experimental: dict[str, dict[str,...bil...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'experimental': FieldInfo(annotation=Union[dict[str, d...
    
    class CClliieennttNNoottiiffiiccaattiioonn(pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]])
     |  ClientNotification(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ClientNotification
     |      pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, InitializedNotification, RootsListChangedNotification]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ClientNotificatio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[CancelledNot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ClientNotification", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[CancelledNotificati...
    
    class CClliieennttRReeqquueesstt(pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]])
     |  ClientRequest(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ClientRequest
     |      pydantic.root_model.RootModel[Union[PingRequest, InitializeRequest, CompleteRequest, SetLevelRequest, GetPromptRequest, ListPromptsRequest, ListResourcesRequest, ListResourceTemplatesRequest, ReadResourceRequest, SubscribeRequest, UnsubscribeRequest, CallToolRequest, ListToolsRequest]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ClientRequest'>, ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[PingRequest,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ClientRequest", valida...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[PingRequest, Initia...
    
    class CClliieennttRReessuulltt(pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]])
     |  ClientResult(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ClientResult
     |      pydantic.root_model.RootModel[Union[EmptyResult, CreateMessageResult, ListRootsResult]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ClientResult'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[EmptyResult,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ClientResult", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[EmptyResult, Create...
    
    class CCoommpplleetteeRReeqquueesstt(Request[CompleteRequestParams, Literal['completion/complete']])
     |  CompleteRequest(*, method: Literal['completion/complete'], params: mcp.types.CompleteRequestParams, **extra_data: Any) -> None
     |  
     |  A request from the client to the server, to ask for completion options.
     |  
     |  Method resolution order:
     |      CompleteRequest
     |      Request[CompleteRequestParams, Literal['completion/complete']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['completion/complete'], 'p...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CompleteRequest'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['complet...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CompleteRequest", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['completion/compl...omp...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['completion/com...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class CCoommpplleetteeRReeqquueessttPPaarraammss(RequestParams)
     |  CompleteRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, ref: mcp.types.ResourceReference | mcp.types.PromptReference, argument: mcp.types.CompletionArgument, **extra_data: Any) -> None
     |  
     |  Parameters for completion requests.
     |  
     |  Method resolution order:
     |      CompleteRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'argument': <class 'mcp.types.CompletionArgument'>,...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CompleteRequestPa...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'argument': FieldInfo(annotation=CompletionArgu...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CompleteRequestParams"...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me...s.C...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'argument': FieldInfo(annotation=CompletionArgument, r...
    
    class CCoommpplleetteeRReessuulltt(Result)
     |  CompleteResult(*, _meta: dict[str, typing.Any] | None = None, completion: mcp.types.Completion, **extra_data: Any) -> None
     |  
     |  The server's response to a completion/complete request
     |  
     |  Method resolution order:
     |      CompleteResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'completion': <class 'mcp.types.Completion'>}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CompleteResult'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'completion': FieldInfo(annotation=Completion, ...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CompleteResult", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...mcp...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'completion': FieldInfo(annotation=Completion, require...
    
    class CCoommpplleettiioonn(pydantic.main.BaseModel)
     |  Completion(*, values: list[str], total: int | None = None, hasMore: bool | None = None, **extra_data: Any) -> None
     |  
     |  Completion information.
     |  
     |  Method resolution order:
     |      Completion
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'hasMore': bool | None, 'total': int | None, 'value...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Completion'>, 'co...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'hasMore': FieldInfo(annotation=Union[bool, Non...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Completion", validator...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, values: list[str], total: int | N...: b...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'hasMore': FieldInfo(annotation=Union[bool, NoneType],...
    
    class CCoommpplleettiioonnAArrgguummeenntt(pydantic.main.BaseModel)
     |  CompletionArgument(*, name: str, value: str, **extra_data: Any) -> None
     |  
     |  The argument's information for completion requests.
     |  
     |  Method resolution order:
     |      CompletionArgument
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'name': <class 'str'>, 'value': <class 'str'>}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CompletionArgumen...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'name': FieldInfo(annotation=str, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CompletionArgument", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str, value: str, **extra_data: An...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'name': FieldInfo(annotation=str, required=True), 'val...
    
    class CCrreeaatteeMMeessssaaggeeRReeqquueesstt(Request[CreateMessageRequestParams, Literal['sampling/createMessage']])
     |  CreateMessageRequest(*, method: Literal['sampling/createMessage'], params: mcp.types.CreateMessageRequestParams, **extra_data: Any) -> None
     |  
     |  A request from the server to sample an LLM via the client.
     |  
     |  Method resolution order:
     |      CreateMessageRequest
     |      Request[CreateMessageRequestParams, Literal['sampling/createMessage']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['sampling/createMessage'],...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CreateMessageRequ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['samplin...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CreateMessageRequest",...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['sampling/createM...Mes...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['sampling/creat...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class CCrreeaatteeMMeessssaaggeeRReeqquueessttPPaarraammss(RequestParams)
     |  CreateMessageRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, messages: list[mcp.types.SamplingMessage], modelPreferences: mcp.types.ModelPreferences | None = None, systemPrompt: str | None = None, includeContext: Optional[Literal['none', 'thisServer', 'allServers']] = None, temperature: float | None = None, maxTokens: int, stopSequences: list[str] | None = None, metadata: dict[str, typing.Any] | None = None, **extra_data: Any) -> None
     |  
     |  Parameters for creating a message.
     |  
     |  Method resolution order:
     |      CreateMessageRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'includeContext': typing.Optional[typing.Literal['n...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CreateMessageRequ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'includeContext': FieldInfo(annotation=Union[Li...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CreateMessageRequestPa...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me...g.A...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'includeContext': FieldInfo(annotation=Union[Literal['...
    
    class CCrreeaatteeMMeessssaaggeeRReessuulltt(Result)
     |  CreateMessageResult(*, _meta: dict[str, typing.Any] | None = None, role: Literal['user', 'assistant'], content: mcp.types.TextContent | mcp.types.ImageContent | mcp.types.AudioContent, model: str, stopReason: Union[Literal['endTurn', 'stopSequence', 'maxTokens'], str, NoneType] = None, **extra_data: Any) -> None
     |  
     |  The client's response to a sampling/create_message request from the server.
     |  
     |  Method resolution order:
     |      CreateMessageResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'content': mcp.types.TextContent | mcp.types.ImageC...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.CreateMessageResu...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'content': FieldInfo(annotation=Union[TextConte...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="CreateMessageResult", ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...tr,...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'content': FieldInfo(annotation=Union[TextContent, Ima...
    
    class EEmmbbeeddddeeddRReessoouurrccee(pydantic.main.BaseModel)
     |  EmbeddedResource(*, type: Literal['resource'], resource: mcp.types.TextResourceContents | mcp.types.BlobResourceContents, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  The contents of a resource, embedded into a prompt or tool call result.
     |  
     |  It is up to the client how best to render embedded resources for the benefit
     |  of the LLM and/or the user.
     |  
     |  Method resolution order:
     |      EmbeddedResource
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'resou...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.EmbeddedResource'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="EmbeddedResource", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['resource'], resour...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class EEmmppttyyRReessuulltt(Result)
     |  EmptyResult(*, _meta: dict[str, typing.Any] | None = None, **extra_data: Any) -> None
     |  
     |  A response that indicates success but carries no data.
     |  
     |  Method resolution order:
     |      EmptyResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.EmptyResult'>, 'c...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="EmptyResult", validato...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | None = N...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class EErrrroorrDDaattaa(pydantic.main.BaseModel)
     |  ErrorData(*, code: int, message: str, data: Optional[Any] = None, **extra_data: Any) -> None
     |  
     |  Error information for JSON-RPC error responses.
     |  
     |  Method resolution order:
     |      ErrorData
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'code': <class 'int'>, 'data': typing.Optional[typi...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ErrorData'>, 'con...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'code': FieldInfo(annotation=int, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ErrorData", validator=...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, code: int, message: str, data: Optional...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'code': FieldInfo(annotation=int, required=True), 'dat...
    
    class GGeettPPrroommppttRReeqquueesstt(Request[GetPromptRequestParams, Literal['prompts/get']])
     |  GetPromptRequest(*, method: Literal['prompts/get'], params: mcp.types.GetPromptRequestParams, **extra_data: Any) -> None
     |  
     |  Used by the client to get a prompt provided by the server.
     |  
     |  Method resolution order:
     |      GetPromptRequest
     |      Request[GetPromptRequestParams, Literal['prompts/get']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['prompts/get'], 'params': ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.GetPromptRequest'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['prompts...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="GetPromptRequest", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['prompts/get'], p...tPr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['prompts/get'],...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class GGeettPPrroommppttRReeqquueessttPPaarraammss(RequestParams)
     |  GetPromptRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, name: str, arguments: dict[str, str] | None = None, **extra_data: Any) -> None
     |  
     |  Parameters for getting a prompt.
     |  
     |  Method resolution order:
     |      GetPromptRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'arguments': dict[str, str] | None, 'name': <class ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.GetPromptRequestP...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'arguments': FieldInfo(annotation=Union[dict[st...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="GetPromptRequestParams...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me..., s...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'arguments': FieldInfo(annotation=Union[dict[str, str]...
    
    class GGeettPPrroommppttRReessuulltt(Result)
     |  GetPromptResult(*, _meta: dict[str, typing.Any] | None = None, description: str | None = None, messages: list[mcp.types.PromptMessage], **extra_data: Any) -> None
     |  
     |  The server's response to a prompts/get request from the client.
     |  
     |  Method resolution order:
     |      GetPromptResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'description': str | None, 'messages': list[mcp.typ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.GetPromptResult'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'description': FieldInfo(annotation=Union[str, ...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="GetPromptResult", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...typ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'description': FieldInfo(annotation=Union[str, NoneTyp...
    
    class IImmaaggeeCCoonntteenntt(pydantic.main.BaseModel)
     |  ImageContent(*, type: Literal['image'], data: str, mimeType: str, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  Image content for a message.
     |  
     |  Method resolution order:
     |      ImageContent
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'data'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ImageContent'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ImageContent", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['image'], data: str...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class IImmpplleemmeennttaattiioonn(pydantic.main.BaseModel)
     |  Implementation(*, name: str, version: str, **extra_data: Any) -> None
     |  
     |  Describes the name and version of an MCP implementation.
     |  
     |  Method resolution order:
     |      Implementation
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'name': <class 'str'>, 'version': <class 'str'>}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Implementation'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'name': FieldInfo(annotation=str, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Implementation", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str, version: str, **extra_data: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'name': FieldInfo(annotation=str, required=True), 'ver...
    
    class IInniittiiaalliizzeeRReeqquueesstt(Request[InitializeRequestParams, Literal['initialize']])
     |  InitializeRequest(*, method: Literal['initialize'], params: mcp.types.InitializeRequestParams, **extra_data: Any) -> None
     |  
     |  This request is sent from the client to the server when it first connects, asking it
     |  to begin initialization.
     |  
     |  Method resolution order:
     |      InitializeRequest
     |      Request[InitializeRequestParams, Literal['initialize']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['initialize'], 'params': <...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.InitializeRequest...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['initial...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="InitializeRequest", va...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['initialize'], pa...tia...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['initialize'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class IInniittiiaalliizzeeRReeqquueessttPPaarraammss(RequestParams)
     |  InitializeRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, protocolVersion: str | int, capabilities: mcp.types.ClientCapabilities, clientInfo: mcp.types.Implementation, **extra_data: Any) -> None
     |  
     |  Parameters for the initialize request.
     |  
     |  Method resolution order:
     |      InitializeRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'capabilities': <class 'mcp.types.ClientCapabilitie...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.InitializeRequest...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'capabilities': FieldInfo(annotation=ClientCapa...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="InitializeRequestParam...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me...typ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'capabilities': FieldInfo(annotation=ClientCapabilitie...
    
    class IInniittiiaalliizzeeRReessuulltt(Result)
     |  InitializeResult(*, _meta: dict[str, typing.Any] | None = None, protocolVersion: str | int, capabilities: mcp.types.ServerCapabilities, serverInfo: mcp.types.Implementation, instructions: str | None = None, **extra_data: Any) -> None
     |  
     |  After receiving an initialize request from the client, the server sends this.
     |  
     |  Method resolution order:
     |      InitializeResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'capabilities': <class 'mcp.types.ServerCapabilitie...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.InitializeResult'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'capabilities': FieldInfo(annotation=ServerCapa...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="InitializeResult", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...s: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'capabilities': FieldInfo(annotation=ServerCapabilitie...
    
    class IInniittiiaalliizzeeddNNoottiiffiiccaattiioonn(Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']])
     |  InitializedNotification(*, method: Literal['notifications/initialized'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |  
     |  This notification is sent from the client to the server after initialization has
     |  finished.
     |  
     |  Method resolution order:
     |      InitializedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/initialized...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.InitializedNotifi...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="InitializedNotificatio...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/in...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class JJSSOONNRRPPCCEErrrroorr(pydantic.main.BaseModel)
     |  JSONRPCError(*, jsonrpc: Literal['2.0'], id: str | int, error: mcp.types.ErrorData, **extra_data: Any) -> None
     |  
     |  A response to a request that indicates an error occurred.
     |  
     |  Method resolution order:
     |      JSONRPCError
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'error': <class 'mcp.types.ErrorData'>, 'id': str |...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.JSONRPCError'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'error': FieldInfo(annotation=ErrorData, requir...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="JSONRPCError", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, jsonrpc: Literal['2.0'], id: str ... mc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'error': FieldInfo(annotation=ErrorData, required=True...
    
    class JJSSOONNRRPPCCMMeessssaaggee(pydantic.root_model.RootModel[Union[JSONRPCRequest, JSONRPCNotification, JSONRPCResponse, JSONRPCError]])
     |  JSONRPCMessage(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      JSONRPCMessage
     |      pydantic.root_model.RootModel[Union[JSONRPCRequest, JSONRPCNotification, JSONRPCResponse, JSONRPCError]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.JSONRPCMessage'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[JSONRPCReque...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="JSONRPCMessage", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[JSONRPCRequest, JSO...
    
    class JJSSOONNRRPPCCNNoottiiffiiccaattiioonn(Notification[Union[dict[str, Any], NoneType], str])
     |  JSONRPCNotification(*, method: str, params: dict[str, typing.Any] | None = None, jsonrpc: Literal['2.0'], **extra_data: Any) -> None
     |  
     |  A notification which does not expect a response.
     |  
     |  Method resolution order:
     |      JSONRPCNotification
     |      Notification[Union[dict[str, Any], NoneType], str]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'jsonrpc': typing.Literal['2.0'], 'params': dict[st...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.JSONRPCNotificati...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'jsonrpc': FieldInfo(annotation=Literal['2.0'],...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="JSONRPCNotification", ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: str, params: dict[str, ty...nrp...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'jsonrpc': FieldInfo(annotation=Literal['2.0'], requir...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class JJSSOONNRRPPCCRReeqquueesstt(Request[Union[dict[str, Any], NoneType], str])
     |  JSONRPCRequest(*, method: str, params: dict[str, typing.Any] | None = None, jsonrpc: Literal['2.0'], id: typing.Annotated[int | str, _PydanticGeneralMetadata(union_mode='left_to_right')], **extra_data: Any) -> None
     |  
     |  A request that expects a response.
     |  
     |  Method resolution order:
     |      JSONRPCRequest
     |      Request[Union[dict[str, Any], NoneType], str]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'id': typing.Annotated[int | str, FieldInfo(annotat...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.JSONRPCRequest'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'id': FieldInfo(annotation=Union[int, str], req...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="JSONRPCRequest", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: str, params: dict[str, ty...de=...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'id': FieldInfo(annotation=Union[int, str], required=T...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class JJSSOONNRRPPCCRReessppoonnssee(pydantic.main.BaseModel)
     |  JSONRPCResponse(*, jsonrpc: Literal['2.0'], id: typing.Annotated[int | str, _PydanticGeneralMetadata(union_mode='left_to_right')], result: dict[str, typing.Any], **extra_data: Any) -> None
     |  
     |  A successful (non-error) response to a request.
     |  
     |  Method resolution order:
     |      JSONRPCResponse
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'id': typing.Annotated[int | str, FieldInfo(annotat...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.JSONRPCResponse'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'id': FieldInfo(annotation=Union[int, str], req...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="JSONRPCResponse", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, jsonrpc: Literal['2.0'], id: typi...ict...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'id': FieldInfo(annotation=Union[int, str], required=T...
    
    class LLiissttPPrroommppttssRReeqquueesstt(PaginatedRequest[Literal['prompts/list']])
     |  ListPromptsRequest(*, method: Literal['prompts/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Sent from the client to request a list of prompts and prompt templates.
     |  
     |  Method resolution order:
     |      ListPromptsRequest
     |      PaginatedRequest[Literal['prompts/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['prompts/list']}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListPromptsReques...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['prompts...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListPromptsRequest", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['prompts/list'], ...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['prompts/list']...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLiissttPPrroommppttssRReessuulltt(PaginatedResult)
     |  ListPromptsResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, prompts: list[mcp.types.Prompt], **extra_data: Any) -> None
     |  
     |  The server's response to a prompts/list request from the client.
     |  
     |  Method resolution order:
     |      ListPromptsResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'prompts': list[mcp.types.Prompt]}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListPromptsResult...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListPromptsResult", va...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...st[...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class LLiissttRReessoouurrcceeTTeemmppllaatteessRReeqquueesstt(PaginatedRequest[Literal['resources/templates/list']])
     |  ListResourceTemplatesRequest(*, method: Literal['resources/templates/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Sent from the client to request a list of resource templates the server has.
     |  
     |  Method resolution order:
     |      ListResourceTemplatesRequest
     |      PaginatedRequest[Literal['resources/templates/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['resources/templates/list'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListResourceTempl...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListResourceTemplatesR...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/templa...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/temp...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLiissttRReessoouurrcceeTTeemmppllaatteessRReessuulltt(PaginatedResult)
     |  ListResourceTemplatesResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, resourceTemplates: list[mcp.types.ResourceTemplate], **extra_data: Any) -> None
     |  
     |  The server's response to a resources/templates/list request from the client.
     |  
     |  Method resolution order:
     |      ListResourceTemplatesResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'resourceTemplates': list[mcp.types.ResourceTemplat...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListResourceTempl...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListResourceTemplatesR...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...es....
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class LLiissttRReessoouurrcceessRReeqquueesstt(PaginatedRequest[Literal['resources/list']])
     |  ListResourcesRequest(*, method: Literal['resources/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Sent from the client to request a list of resources the server has.
     |  
     |  Method resolution order:
     |      ListResourcesRequest
     |      PaginatedRequest[Literal['resources/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['resources/list']}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListResourcesRequ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListResourcesRequest",...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/list']...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/list...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLiissttRReessoouurrcceessRReessuulltt(PaginatedResult)
     |  ListResourcesResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, resources: list[mcp.types.Resource], **extra_data: Any) -> None
     |  
     |  The server's response to a resources/list request from the client.
     |  
     |  Method resolution order:
     |      ListResourcesResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'resources': list[mcp.types.Resource]}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListResourcesResu...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListResourcesResult", ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...[mc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class LLiissttRRoooottssRReeqquueesstt(Request[Union[RequestParams, NoneType], Literal['roots/list']])
     |  ListRootsRequest(*, method: Literal['roots/list'], params: mcp.types.RequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Sent from the server to request a list of root URIs from the client. Roots allow
     |  servers to ask for specific directories or files to operate on. A common example
     |  for roots is providing a set of repositories or directories a server should operate
     |  on.
     |  
     |  This request is typically used when the server needs to understand the file system
     |  structure or access specific locations that the client has permission to read from.
     |  
     |  Method resolution order:
     |      ListRootsRequest
     |      Request[Union[RequestParams, NoneType], Literal['roots/list']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['roots/list'], 'params': m...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListRootsRequest'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['roots/l...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListRootsRequest", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['roots/list'], pa...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['roots/list'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLiissttRRoooottssRReessuulltt(Result)
     |  ListRootsResult(*, _meta: dict[str, typing.Any] | None = None, roots: list[mcp.types.Root], **extra_data: Any) -> None
     |  
     |  The client's response to a roots/list request from the server.
     |  This result contains an array of Root objects, each representing a root directory
     |  or file that the server can operate on.
     |  
     |  Method resolution order:
     |      ListRootsResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'roots': list[mcp.types.Root]}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListRootsResult'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListRootsResult", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...lis...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class LLiissttTToooollssRReeqquueesstt(PaginatedRequest[Literal['tools/list']])
     |  ListToolsRequest(*, method: Literal['tools/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Sent from the client to request a list of tools the server has.
     |  
     |  Method resolution order:
     |      ListToolsRequest
     |      PaginatedRequest[Literal['tools/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['tools/list']}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListToolsRequest'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['tools/l...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListToolsRequest", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['tools/list'], pa...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['tools/list'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLiissttTToooollssRReessuulltt(PaginatedResult)
     |  ListToolsResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, tools: list[mcp.types.Tool], **extra_data: Any) -> None
     |  
     |  The server's response to a tools/list request from the client.
     |  
     |  Method resolution order:
     |      ListToolsResult
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'tools': list[mcp.types.Tool]}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ListToolsResult'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ListToolsResult", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...lis...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class LLooggggiinnggCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  LoggingCapability(**extra_data: Any) -> None
     |  
     |  Capability for logging operations.
     |  
     |  Method resolution order:
     |      LoggingCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.LoggingCapability...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="LoggingCapability", va...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (**extra_data: Any) -> None>
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {}
    
    class LLooggggiinnggMMeessssaaggeeNNoottiiffiiccaattiioonn(Notification[LoggingMessageNotificationParams, Literal['notifications/message']])
     |  LoggingMessageNotification(*, method: Literal['notifications/message'], params: mcp.types.LoggingMessageNotificationParams, **extra_data: Any) -> None
     |  
     |  Notification of a log message passed from server to client.
     |  
     |  Method resolution order:
     |      LoggingMessageNotification
     |      Notification[LoggingMessageNotificationParams, Literal['notifications/message']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/message'], ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.LoggingMessageNot...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="LoggingMessageNotifica...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/me...geN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class LLooggggiinnggMMeessssaaggeeNNoottiiffiiccaattiioonnPPaarraammss(NotificationParams)
     |  LoggingMessageNotificationParams(*, _meta: mcp.types.NotificationParams.Meta | None = None, level: Literal['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency'], logger: str | None = None, data: Any, **extra_data: Any) -> None
     |  
     |  Parameters for logging message notifications.
     |  
     |  Method resolution order:
     |      LoggingMessageNotificationParams
     |      NotificationParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'data': typing.Any, 'level': typing.Literal['debug'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.LoggingMessageNot...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'data': FieldInfo(annotation=Any, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="LoggingMessageNotifica...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.NotificationPara...ne ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NotificationParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NotificationParams:
     |  
     |  MMeettaa = <class 'mcp.types.NotificationParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'data': FieldInfo(annotation=Any, required=True), 'lev...
    
    class MMooddeellHHiinntt(pydantic.main.BaseModel)
     |  ModelHint(*, name: str | None = None, **extra_data: Any) -> None
     |  
     |  Hints to use for model selection.
     |  
     |  Method resolution order:
     |      ModelHint
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'name': str | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ModelHint'>, 'con...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'name': FieldInfo(annotation=Union[str, NoneTyp...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ModelHint", validator=...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str | None = None, **extra_data: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'name': FieldInfo(annotation=Union[str, NoneType], req...
    
    class MMooddeellPPrreeffeerreenncceess(pydantic.main.BaseModel)
     |  ModelPreferences(*, hints: list[mcp.types.ModelHint] | None = None, costPriority: float | None = None, speedPriority: float | None = None, intelligencePriority: float | None = None, **extra_data: Any) -> None
     |  
     |  The server's preferences for model selection, requested by the client during
     |  sampling.
     |  
     |  Because LLMs can vary along multiple dimensions, choosing the "best" model is
     |  rarely straightforward.  Different models excel in different areas—some are
     |  faster but less capable, others are more capable but more expensive, and so
     |  on. This interface allows servers to express their priorities across multiple
     |  dimensions to help clients make an appropriate selection for their use case.
     |  
     |  These preferences are always advisory. The client MAY ignore them. It is also
     |  up to the client to decide how to interpret these preferences and how to
     |  balance them against other considerations.
     |  
     |  Method resolution order:
     |      ModelPreferences
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'costPriority': float | None, 'hints': list[mcp.typ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ModelPreferences'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'costPriority': FieldInfo(annotation=Union[floa...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ModelPreferences", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, hints: list[mcp.types.ModelHint] ... fl...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'costPriority': FieldInfo(annotation=Union[float, None...
    
    class NNoottiiffiiccaattiioonn(pydantic.main.BaseModel, typing.Generic)
     |  Notification(*, method: ~MethodT, params: ~NotificationParamsT, **extra_data: Any) -> None
     |  
     |  Base class for JSON-RPC notifications.
     |  
     |  Method resolution order:
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': ~MethodT, 'params': ~NotificationParamsT}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppaarraammeetteerrss____ = (~NotificationParamsT, ~MethodT)
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=~MethodT, requir...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: ~MethodT, params: ~Notification...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=~MethodT, required=True...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonnPPaarraammss(pydantic.main.BaseModel)
     |  NotificationParams(*, _meta: mcp.types.NotificationParams.Meta | None = None) -> None
     |  
     |  Method resolution order:
     |      NotificationParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  MMeettaa = <class 'mcp.types.NotificationParams.Meta'>
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'meta': mcp.types.NotificationParams.Meta | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.NotificationParam...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[Notification...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="NotificationParams", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.NotificationParams.Met...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[NotificationParams....
    
    class NNoottiiffiiccaattiioonn[[CCaanncceelllleeddNNoottiiffiiccaattiioonnPPaarraammss,,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//ccaanncceelllleedd'']]]](Notification)
     |  Notification[CancelledNotificationParams, Literal['notifications/cancelled']](*, method: Literal['notifications/cancelled'], params: mcp.types.CancelledNotificationParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[CancelledNotificationParams, Literal['notifications/cancelled']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Canc...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.CancelledN...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Cancelled...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/ca...edN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[LLooggggiinnggMMeessssaaggeeNNoottiiffiiccaattiioonnPPaarraammss,,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//mmeessssaaggee'']]]](Notification)
     |  Notification[LoggingMessageNotificationParams, Literal['notifications/message']](*, method: Literal['notifications/message'], params: mcp.types.LoggingMessageNotificationParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[LoggingMessageNotificationParams, Literal['notifications/message']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Logg...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.LoggingMes...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[LoggingMe...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/me...geN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[PPrrooggrreessssNNoottiiffiiccaattiioonnPPaarraammss,,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//pprrooggrreessss'']]]](Notification)
     |  Notification[ProgressNotificationParams, Literal['notifications/progress']](*, method: Literal['notifications/progress'], params: mcp.types.ProgressNotificationParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[ProgressNotificationParams, Literal['notifications/progress']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Prog...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.ProgressNo...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[ProgressN...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/pr...ssN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[RReessoouurrcceeUUppddaatteeddNNoottiiffiiccaattiioonnPPaarraammss,,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//rreessoouurrcceess//uuppddaatteedd'']]]](Notification)
     |  Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']](*, method: Literal['notifications/resources/updated'], params: mcp.types.ResourceUpdatedNotificationParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Reso...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.ResourceUp...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[ResourceU...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/re...edN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[NNoottiiffiiccaattiioonnPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//iinniittiiaalliizzeedd'']]]](Notification)
     |  Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']](*, method: Literal['notifications/initialized'], params: mcp.types.NotificationParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/initialized']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.NotificationParams...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[Not...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/in...ica...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[NNoottiiffiiccaattiioonnPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//pprroommppttss//lliisstt__cchhaannggeedd'']]]](Notification)
     |  Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']](*, method: Literal['notifications/prompts/list_changed'], params: mcp.types.NotificationParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.NotificationParams...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[Not...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/pr...ica...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[NNoottiiffiiccaattiioonnPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//rreessoouurrcceess//lliisstt__cchhaannggeedd'']]]](Notification)
     |  Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']](*, method: Literal['notifications/resources/list_changed'], params: mcp.types.NotificationParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.NotificationParams...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[Not...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/re...ica...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[NNoottiiffiiccaattiioonnPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//rroooottss//lliisstt__cchhaannggeedd'']]]](Notification)
     |  Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']](*, method: Literal['notifications/roots/list_changed'], params: mcp.types.NotificationParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.NotificationParams...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[Not...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/ro...ica...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[NNoottiiffiiccaattiioonnPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''nnoottiiffiiccaattiioonnss//ttoooollss//lliisstt__cchhaannggeedd'']]]](Notification)
     |  Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']](*, method: Literal['notifications/tools/list_changed'], params: mcp.types.NotificationParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.NotificationParams...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[Not...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/to...ica...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class NNoottiiffiiccaattiioonn[[UUnniioonn[[ddiicctt[[ssttrr,,  AAnnyy]],,  NNoonneeTTyyppee]],,  ssttrr]](Notification)
     |  Notification[Union[dict[str, Any], NoneType], str](*, method: str, params: dict[str, typing.Any] | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Notification[Union[dict[str, Any], NoneType], str]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Notification[Unio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=str, required=Tr...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (dict[str, typing.Any] | None...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Notification[Union[dic...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: str, params: dict[str, typing.A...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=str, required=True), 'p...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReeqquueesstt(Request[Union[PaginatedRequestParams, NoneType], ~MethodT], typing.Generic)
     |  PaginatedRequest(*, method: ~MethodT, params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Base class for paginated requests,
     |  matching the schema's PaginatedRequest interface.
     |  
     |  Method resolution order:
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'params': mcp.types.PaginatedRequestParams | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ____ppaarraammeetteerrss____ = (~MethodT,)
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequest'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=~MethodT, requir...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequest", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: ~MethodT, params: mcp.typ...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=~MethodT, required=True...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReeqquueessttPPaarraammss(RequestParams)
     |  PaginatedRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, cursor: str | None = None) -> None
     |  
     |  Method resolution order:
     |      PaginatedRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'cursor': str | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequestP...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'cursor': FieldInfo(annotation=Union[str, NoneT...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequestParams...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me... No...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'cursor': FieldInfo(annotation=Union[str, NoneType], r...
    
    class PPaaggiinnaatteeddRReeqquueesstt[[LLiitteerraall[[''pprroommppttss//lliisstt'']]]](PaginatedRequest)
     |  PaginatedRequest[Literal['prompts/list']](*, method: Literal['prompts/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      PaginatedRequest[Literal['prompts/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequest[...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['prompts...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (typing.Literal['prompts/list...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequest[Liter...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['prompts/list'], ...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['prompts/list']...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReeqquueesstt[[LLiitteerraall[[''rreessoouurrcceess//lliisstt'']]]](PaginatedRequest)
     |  PaginatedRequest[Literal['resources/list']](*, method: Literal['resources/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      PaginatedRequest[Literal['resources/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequest[...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (typing.Literal['resources/li...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequest[Liter...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/list']...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/list...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReeqquueesstt[[LLiitteerraall[[''rreessoouurrcceess//tteemmppllaatteess//lliisstt'']]]](PaginatedRequest)
     |  PaginatedRequest[Literal['resources/templates/list']](*, method: Literal['resources/templates/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      PaginatedRequest[Literal['resources/templates/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequest[...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (typing.Literal['resources/te...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequest[Liter...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/templa...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/temp...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReeqquueesstt[[LLiitteerraall[[''ttoooollss//lliisstt'']]]](PaginatedRequest)
     |  PaginatedRequest[Literal['tools/list']](*, method: Literal['tools/list'], params: mcp.types.PaginatedRequestParams | None = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      PaginatedRequest[Literal['tools/list']]
     |      PaginatedRequest
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedRequest[...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['tools/l...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (typing.Literal['tools/list']...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedRequest[Liter...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['tools/list'], pa...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from PaginatedRequest:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'mcp.types.Request[Union[PaginatedRequestPara...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['tools/list'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPaaggiinnaatteeddRReessuulltt(Result)
     |  PaginatedResult(*, _meta: dict[str, typing.Any] | None = None, nextCursor: str | None = None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      PaginatedResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'nextCursor': str | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PaginatedResult'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PaginatedResult", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...r: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class PPiinnggRReeqquueesstt(Request[Union[RequestParams, NoneType], Literal['ping']])
     |  PingRequest(*, method: Literal['ping'], params: mcp.types.RequestParams | None = None, **extra_data: Any) -> None
     |  
     |  A ping, issued by either the server or the client, to check that the other party is
     |  still alive.
     |  
     |  Method resolution order:
     |      PingRequest
     |      Request[Union[RequestParams, NoneType], Literal['ping']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['ping'], 'params': mcp.typ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PingRequest'>, 'c...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['ping'],...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PingRequest", validato...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['ping'], params: ...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['ping'], requir...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPrrooggrreessssNNoottiiffiiccaattiioonn(Notification[ProgressNotificationParams, Literal['notifications/progress']])
     |  ProgressNotification(*, method: Literal['notifications/progress'], params: mcp.types.ProgressNotificationParams, **extra_data: Any) -> None
     |  
     |  An out-of-band notification used to inform the receiver of a progress update for a
     |  long-running request.
     |  
     |  Method resolution order:
     |      ProgressNotification
     |      Notification[ProgressNotificationParams, Literal['notifications/progress']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/progress'],...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ProgressNotificat...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ProgressNotification",...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/pr...ssN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPrrooggrreessssNNoottiiffiiccaattiioonnPPaarraammss(NotificationParams)
     |  ProgressNotificationParams(*, _meta: mcp.types.NotificationParams.Meta | None = None, progressToken: str | int, progress: float, total: float | None = None, message: str | None = None, **extra_data: Any) -> None
     |  
     |  Parameters for progress notifications.
     |  
     |  Method resolution order:
     |      ProgressNotificationParams
     |      NotificationParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'message': str | None, 'progress': <class 'float'>,...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ProgressNotificat...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'message': FieldInfo(annotation=Union[str, None...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ProgressNotificationPa...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.NotificationPara...e: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NotificationParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NotificationParams:
     |  
     |  MMeettaa = <class 'mcp.types.NotificationParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'message': FieldInfo(annotation=Union[str, NoneType], ...
    
    class PPrroommpptt(pydantic.main.BaseModel)
     |  Prompt(*, name: str, description: str | None = None, arguments: list[mcp.types.PromptArgument] | None = None, **extra_data: Any) -> None
     |  
     |  A prompt or prompt template that the server offers.
     |  
     |  Method resolution order:
     |      Prompt
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'arguments': list[mcp.types.PromptArgument] | None,...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Prompt'>, 'config...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'arguments': FieldInfo(annotation=Union[list[Pr...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Prompt", validator=Mod...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str, description: str | Non...ume...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'arguments': FieldInfo(annotation=Union[list[PromptArg...
    
    class PPrroommppttAArrgguummeenntt(pydantic.main.BaseModel)
     |  PromptArgument(*, name: str, description: str | None = None, required: bool | None = None, **extra_data: Any) -> None
     |  
     |  An argument for a prompt template.
     |  
     |  Method resolution order:
     |      PromptArgument
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'description': str | None, 'name': <class 'str'>, '...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PromptArgument'>,...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'description': FieldInfo(annotation=Union[str, ...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PromptArgument", valid...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str, description: str | Non...: b...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'description': FieldInfo(annotation=Union[str, NoneTyp...
    
    class PPrroommppttLLiissttCChhaannggeeddNNoottiiffiiccaattiioonn(Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']])
     |  PromptListChangedNotification(*, method: Literal['notifications/prompts/list_changed'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |  
     |  An optional notification from the server to the client, informing it that the list
     |  of prompts it offers has changed.
     |  
     |  Method resolution order:
     |      PromptListChangedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/prompts/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/prompts/lis...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PromptListChanged...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PromptListChangedNotif...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/pr...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class PPrroommppttMMeessssaaggee(pydantic.main.BaseModel)
     |  PromptMessage(*, role: Literal['user', 'assistant'], content: mcp.types.TextContent | mcp.types.ImageContent | mcp.types.AudioContent | mcp.types.EmbeddedResource, **extra_data: Any) -> None
     |  
     |  Describes a message returned as part of a prompt.
     |  
     |  Method resolution order:
     |      PromptMessage
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'content': mcp.types.TextContent | mcp.types.ImageC...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PromptMessage'>, ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'content': FieldInfo(annotation=Union[TextConte...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PromptMessage", valida...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, role: Literal['user', 'assistant'...pes...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'content': FieldInfo(annotation=Union[TextContent, Ima...
    
    class PPrroommppttRReeffeerreennccee(pydantic.main.BaseModel)
     |  PromptReference(*, type: Literal['ref/prompt'], name: str, **extra_data: Any) -> None
     |  
     |  Identifies a prompt.
     |  
     |  Method resolution order:
     |      PromptReference
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'name': <class 'str'>, 'type': typing.Literal['ref/...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PromptReference'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'name': FieldInfo(annotation=str, required=True...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PromptReference", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['ref/prompt'], name: str,...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'name': FieldInfo(annotation=str, required=True), 'typ...
    
    class PPrroommppttssCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  PromptsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |  
     |  Capability for prompts operations.
     |  
     |  Method resolution order:
     |      PromptsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'listChanged': bool | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.PromptsCapability...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="PromptsCapability", va...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, listChanged: bool | None = None, **extr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...
    
    class RReeaaddRReessoouurrcceeRReeqquueesstt(Request[ReadResourceRequestParams, Literal['resources/read']])
     |  ReadResourceRequest(*, method: Literal['resources/read'], params: mcp.types.ReadResourceRequestParams, **extra_data: Any) -> None
     |  
     |  Sent from the client to the server, to read a specific resource URI.
     |  
     |  Method resolution order:
     |      ReadResourceRequest
     |      Request[ReadResourceRequestParams, Literal['resources/read']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['resources/read'], 'params...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ReadResourceReque...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ReadResourceRequest", ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/read']...eso...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/read...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeaaddRReessoouurrcceeRReeqquueessttPPaarraammss(RequestParams)
     |  ReadResourceRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], **extra_data: Any) -> None
     |  
     |  Parameters for reading a resource.
     |  
     |  Method resolution order:
     |      ReadResourceRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'uri': typing.Annotated[pydantic.networks.AnyUrl, U...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ReadResourceReque...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[RequestParam...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ReadResourceRequestPar...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me... de...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[RequestParams.Meta,...
    
    class RReeaaddRReessoouurrcceeRReessuulltt(Result)
     |  ReadResourceResult(*, _meta: dict[str, typing.Any] | None = None, contents: list[mcp.types.TextResourceContents | mcp.types.BlobResourceContents], **extra_data: Any) -> None
     |  
     |  The server's response to a resources/read request from the client.
     |  
     |  Method resolution order:
     |      ReadResourceResult
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'contents': list[mcp.types.TextResourceContents | m...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ReadResourceResul...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'contents': FieldInfo(annotation=list[Union[Tex...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ReadResourceResult", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | No...lob...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Result:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'contents': FieldInfo(annotation=list[Union[TextResour...
    
    class RReeqquueesstt(pydantic.main.BaseModel, typing.Generic)
     |  Request(*, method: ~MethodT, params: ~RequestParamsT, **extra_data: Any) -> None
     |  
     |  Base class for JSON-RPC requests.
     |  
     |  Method resolution order:
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': ~MethodT, 'params': ~RequestParamsT}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppaarraammeetteerrss____ = (~RequestParamsT, ~MethodT)
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request'>, 'confi...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=~MethodT, requir...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request", validator=Mo...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: ~MethodT, params: ~RequestParam...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=~MethodT, required=True...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueessttPPaarraammss(pydantic.main.BaseModel)
     |  RequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None) -> None
     |  
     |  Method resolution order:
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'meta': mcp.types.RequestParams.Meta | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.RequestParams'>, ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[RequestParam...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="RequestParams", valida...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Meta | N...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[RequestParams.Meta,...
    
    class RReeqquueesstt[[CCaallllTToooollRReeqquueessttPPaarraammss,,  LLiitteerraall[[''ttoooollss//ccaallll'']]]](Request)
     |  Request[CallToolRequestParams, Literal['tools/call']](*, method: Literal['tools/call'], params: mcp.types.CallToolRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[CallToolRequestParams, Literal['tools/call']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[CallToolR...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['tools/c...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.CallToolRe...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[CallToolReques...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['tools/call'], pa...all...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['tools/call'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[CCoommpplleetteeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''ccoommpplleettiioonn//ccoommpplleettee'']]]](Request)
     |  Request[CompleteRequestParams, Literal['completion/complete']](*, method: Literal['completion/complete'], params: mcp.types.CompleteRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[CompleteRequestParams, Literal['completion/complete']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[CompleteR...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['complet...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.CompleteRe...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[CompleteReques...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['completion/compl...omp...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['completion/com...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[CCrreeaatteeMMeessssaaggeeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''ssaammpplliinngg//ccrreeaatteeMMeessssaaggee'']]]](Request)
     |  Request[CreateMessageRequestParams, Literal['sampling/createMessage']](*, method: Literal['sampling/createMessage'], params: mcp.types.CreateMessageRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[CreateMessageRequestParams, Literal['sampling/createMessage']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[CreateMes...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['samplin...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.CreateMess...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[CreateMessageR...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['sampling/createM...Mes...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['sampling/creat...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[GGeettPPrroommppttRReeqquueessttPPaarraammss,,  LLiitteerraall[[''pprroommppttss//ggeett'']]]](Request)
     |  Request[GetPromptRequestParams, Literal['prompts/get']](*, method: Literal['prompts/get'], params: mcp.types.GetPromptRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[GetPromptRequestParams, Literal['prompts/get']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[GetPrompt...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['prompts...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.GetPromptR...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[GetPromptReque...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['prompts/get'], p...tPr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['prompts/get'],...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[IInniittiiaalliizzeeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''iinniittiiaalliizzee'']]]](Request)
     |  Request[InitializeRequestParams, Literal['initialize']](*, method: Literal['initialize'], params: mcp.types.InitializeRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[InitializeRequestParams, Literal['initialize']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Initializ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['initial...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.Initialize...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[InitializeRequ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['initialize'], pa...tia...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['initialize'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[RReeaaddRReessoouurrcceeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''rreessoouurrcceess//rreeaadd'']]]](Request)
     |  Request[ReadResourceRequestParams, Literal['resources/read']](*, method: Literal['resources/read'], params: mcp.types.ReadResourceRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[ReadResourceRequestParams, Literal['resources/read']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[ReadResou...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.ReadResour...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[ReadResourceRe...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/read']...eso...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/read...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[SSeettLLeevveellRReeqquueessttPPaarraammss,,  LLiitteerraall[[''llooggggiinngg//sseettLLeevveell'']]]](Request)
     |  Request[SetLevelRequestParams, Literal['logging/setLevel']](*, method: Literal['logging/setLevel'], params: mcp.types.SetLevelRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[SetLevelRequestParams, Literal['logging/setLevel']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[SetLevelR...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['logging...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.SetLevelRe...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[SetLevelReques...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['logging/setLevel...etL...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['logging/setLev...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[SSuubbssccrriibbeeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''rreessoouurrcceess//ssuubbssccrriibbee'']]]](Request)
     |  Request[SubscribeRequestParams, Literal['resources/subscribe']](*, method: Literal['resources/subscribe'], params: mcp.types.SubscribeRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[SubscribeRequestParams, Literal['resources/subscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Subscribe...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.SubscribeR...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[SubscribeReque...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/subscr...bsc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/subs...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[UUnniioonn[[PPaaggiinnaatteeddRReeqquueessttPPaarraammss,,  NNoonneeTTyyppee]],,  ~~MMeetthhooddTT]](Request)
     |  Request[Union[PaginatedRequestParams, NoneType], ~MethodT](*, method: ~MethodT, params: mcp.types.PaginatedRequestParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[Union[PaginatedRequestParams, NoneType], ~MethodT]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Union[Pag...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=~MethodT, requir...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.PaginatedRequestPa...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[Union[Paginate...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: ~MethodT, params: mcp.typ...Req...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=~MethodT, required=True...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[UUnniioonn[[RReeqquueessttPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''ppiinngg'']]]](Request)
     |  Request[Union[RequestParams, NoneType], Literal['ping']](*, method: Literal['ping'], params: mcp.types.RequestParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[Union[RequestParams, NoneType], Literal['ping']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Union[Req...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['ping'],...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.RequestParams | No...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[Union[RequestP...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['ping'], params: ...Req...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['ping'], requir...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[UUnniioonn[[RReeqquueessttPPaarraammss,,  NNoonneeTTyyppee]],,  LLiitteerraall[[''rroooottss//lliisstt'']]]](Request)
     |  Request[Union[RequestParams, NoneType], Literal['roots/list']](*, method: Literal['roots/list'], params: mcp.types.RequestParams | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[Union[RequestParams, NoneType], Literal['roots/list']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Union[Req...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['roots/l...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (mcp.types.RequestParams | No...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[Union[RequestP...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['roots/list'], pa...Req...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['roots/list'], ...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[UUnniioonn[[ddiicctt[[ssttrr,,  AAnnyy]],,  NNoonneeTTyyppee]],,  ssttrr]](Request)
     |  Request[Union[dict[str, Any], NoneType], str](*, method: str, params: dict[str, typing.Any] | None, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[Union[dict[str, Any], NoneType], str]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Union[dic...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=str, required=Tr...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (dict[str, typing.Any] | None...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[Union[dict[str...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: str, params: dict[str, typing.A...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=str, required=True), 'p...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReeqquueesstt[[UUnnssuubbssccrriibbeeRReeqquueessttPPaarraammss,,  LLiitteerraall[[''rreessoouurrcceess//uunnssuubbssccrriibbee'']]]](Request)
     |  Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']](*, method: Literal['resources/unsubscribe'], params: mcp.types.UnsubscribeRequestParams, **extra_data: Any) -> None
     |  
     |  Method resolution order:
     |      Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Request[Unsubscri...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (<class 'mcp.types.Unsubscrib...
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Request[UnsubscribeReq...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/unsubs...bsc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/unsu...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReessoouurrccee(pydantic.main.BaseModel)
     |  Resource(*, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], name: str, description: str | None = None, mimeType: str | None = None, size: int | None = None, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  A known resource that the server is capable of reading.
     |  
     |  Method resolution order:
     |      Resource
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'descr...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Resource'>, 'conf...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Resource", validator=M...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uri: typing.Annotated[pydantic.ne...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class RReessoouurrcceeCCoonntteennttss(pydantic.main.BaseModel)
     |  ResourceContents(*, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], mimeType: str | None = None, **extra_data: Any) -> None
     |  
     |  The contents of a specific resource or sub-resource.
     |  
     |  Method resolution order:
     |      ResourceContents
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'mimeType': str | None, 'uri': typing.Annotated[pyd...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceContents'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'mimeType': FieldInfo(annotation=Union[str, Non...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceContents", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uri: typing.Annotated[pydantic.ne...e: ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'mimeType': FieldInfo(annotation=Union[str, NoneType],...
    
    class RReessoouurrcceeLLiissttCChhaannggeeddNNoottiiffiiccaattiioonn(Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']])
     |  ResourceListChangedNotification(*, method: Literal['notifications/resources/list_changed'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |  
     |  An optional notification from the server to the client, informing it that the list
     |  of resources it can read from has changed.
     |  
     |  Method resolution order:
     |      ResourceListChangedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/resources/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/resources/l...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceListChang...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceListChangedNot...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/re...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReessoouurrcceeRReeffeerreennccee(pydantic.main.BaseModel)
     |  ResourceReference(*, type: Literal['ref/resource'], uri: str, **extra_data: Any) -> None
     |  
     |  A reference to a resource or resource template definition.
     |  
     |  Method resolution order:
     |      ResourceReference
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'type': typing.Literal['ref/resource'], 'uri': <cla...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceReference...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'type': FieldInfo(annotation=Literal['ref/resou...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceReference", va...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['ref/resource'], uri: str...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'type': FieldInfo(annotation=Literal['ref/resource'], ...
    
    class RReessoouurrcceeTTeemmppllaattee(pydantic.main.BaseModel)
     |  ResourceTemplate(*, uriTemplate: str, name: str, description: str | None = None, mimeType: str | None = None, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  A template description for resources available on the server.
     |  
     |  Method resolution order:
     |      ResourceTemplate
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'descr...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceTemplate'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceTemplate", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uriTemplate: str, name: str, desc...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class RReessoouurrcceeUUppddaatteeddNNoottiiffiiccaattiioonn(Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']])
     |  ResourceUpdatedNotification(*, method: Literal['notifications/resources/updated'], params: mcp.types.ResourceUpdatedNotificationParams, **extra_data: Any) -> None
     |  
     |  A notification from the server to the client, informing it that a resource has
     |  changed and may need to be read again.
     |  
     |  Method resolution order:
     |      ResourceUpdatedNotification
     |      Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/resources/u...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceUpdatedNo...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceUpdatedNotific...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/re...edN...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class RReessoouurrcceeUUppddaatteeddNNoottiiffiiccaattiioonnPPaarraammss(NotificationParams)
     |  ResourceUpdatedNotificationParams(*, _meta: mcp.types.NotificationParams.Meta | None = None, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], **extra_data: Any) -> None
     |  
     |  Parameters for resource update notifications.
     |  
     |  Method resolution order:
     |      ResourceUpdatedNotificationParams
     |      NotificationParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'uri': typing.Annotated[pydantic.networks.AnyUrl, U...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourceUpdatedNo...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[Notification...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourceUpdatedNotific...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.NotificationPara... de...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from NotificationParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from NotificationParams:
     |  
     |  MMeettaa = <class 'mcp.types.NotificationParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[NotificationParams....
    
    class RReessoouurrcceessCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  ResourcesCapability(*, subscribe: bool | None = None, listChanged: bool | None = None, **extra_data: Any) -> None
     |  
     |  Capability for resources operations.
     |  
     |  Method resolution order:
     |      ResourcesCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'listChanged': bool | None, 'subscribe': bool | Non...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ResourcesCapabili...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ResourcesCapability", ...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, subscribe: bool | None = None, li...: b...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...
    
    class RReessuulltt(pydantic.main.BaseModel)
     |  Result(*, _meta: dict[str, typing.Any] | None = None, **extra_data: Any) -> None
     |  
     |  Base class for JSON-RPC results.
     |  
     |  Method resolution order:
     |      Result
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'meta': dict[str, typing.Any] | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Result'>, 'config...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[dict[str, An...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Result", validator=Mod...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: dict[str, typing.Any] | None = N...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[dict[str, Any], Non...
    
    class RRoooott(pydantic.main.BaseModel)
     |  Root(*, uri: pydantic.networks.FileUrl, name: str | None = None, **extra_data: Any) -> None
     |  
     |  Represents a root directory or file that the server can operate on.
     |  
     |  Method resolution order:
     |      Root
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'name': str | None, 'uri': <class 'pydantic.network...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Root'>, 'config':...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'name': FieldInfo(annotation=Union[str, NoneTyp...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Root", validator=Model...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uri: pydantic.networks.FileUrl, name: s...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'name': FieldInfo(annotation=Union[str, NoneType], req...
    
    class RRoooottssCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  RootsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |  
     |  Capability for root operations.
     |  
     |  Method resolution order:
     |      RootsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'listChanged': bool | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.RootsCapability'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="RootsCapability", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, listChanged: bool | None = None, **extr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...
    
    class RRoooottssLLiissttCChhaannggeeddNNoottiiffiiccaattiioonn(Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']])
     |  RootsListChangedNotification(*, method: Literal['notifications/roots/list_changed'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |  
     |  A notification from the client to the server, informing it that the list of
     |  roots has changed.
     |  
     |  This notification should be sent whenever the client adds, removes, or
     |  modifies any root. The server should then request an updated list of roots
     |  using the ListRootsRequest.
     |  
     |  Method resolution order:
     |      RootsListChangedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/roots/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/roots/list_...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.RootsListChangedN...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="RootsListChangedNotifi...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/ro...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class SSaammpplliinnggCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  SamplingCapability(**extra_data: Any) -> None
     |  
     |  Capability for sampling operations.
     |  
     |  Method resolution order:
     |      SamplingCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SamplingCapabilit...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SamplingCapability", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (**extra_data: Any) -> None>
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {}
    
    class SSaammpplliinnggMMeessssaaggee(pydantic.main.BaseModel)
     |  SamplingMessage(*, role: Literal['user', 'assistant'], content: mcp.types.TextContent | mcp.types.ImageContent | mcp.types.AudioContent, **extra_data: Any) -> None
     |  
     |  Describes a message issued to or received from an LLM API.
     |  
     |  Method resolution order:
     |      SamplingMessage
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'content': mcp.types.TextContent | mcp.types.ImageC...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SamplingMessage'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'content': FieldInfo(annotation=Union[TextConte...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SamplingMessage", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, role: Literal['user', 'assistant'...p.t...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'content': FieldInfo(annotation=Union[TextContent, Ima...
    
    class SSeerrvveerrCCaappaabbiilliittiieess(pydantic.main.BaseModel)
     |  ServerCapabilities(*, experimental: dict[str, dict[str, typing.Any]] | None = None, logging: mcp.types.LoggingCapability | None = None, prompts: mcp.types.PromptsCapability | None = None, resources: mcp.types.ResourcesCapability | None = None, tools: mcp.types.ToolsCapability | None = None, **extra_data: Any) -> None
     |  
     |  Capabilities that a server may support.
     |  
     |  Method resolution order:
     |      ServerCapabilities
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'experimental': dict[str, dict[str, typing.Any]] | ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ServerCapabilitie...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'experimental': FieldInfo(annotation=Union[dict...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ServerCapabilities", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, experimental: dict[str, dict[str,...bil...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'experimental': FieldInfo(annotation=Union[dict[str, d...
    
    class SSeerrvveerrNNoottiiffiiccaattiioonn(pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]])
     |  ServerNotification(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ServerNotification
     |      pydantic.root_model.RootModel[Union[CancelledNotification, ProgressNotification, LoggingMessageNotification, ResourceUpdatedNotification, ResourceListChangedNotification, ToolListChangedNotification, PromptListChangedNotification]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ServerNotificatio...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[CancelledNot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ServerNotification", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[CancelledNotificati...
    
    class SSeerrvveerrRReeqquueesstt(pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]])
     |  ServerRequest(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ServerRequest
     |      pydantic.root_model.RootModel[Union[PingRequest, CreateMessageRequest, ListRootsRequest]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ServerRequest'>, ...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[PingRequest,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ServerRequest", valida...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[PingRequest, Create...
    
    class SSeerrvveerrRReessuulltt(pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]])
     |  ServerResult(root: 'RootModelRootType' = PydanticUndefined) -> None
     |  
     |  Method resolution order:
     |      ServerResult
     |      pydantic.root_model.RootModel[Union[EmptyResult, InitializeResult, CompleteResult, GetPromptResult, ListPromptsResult, ListResourcesResult, ListResourceTemplatesResult, ReadResourceResult, CallToolResult, ListToolsResult]]
     |      pydantic.root_model.RootModel
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ServerResult'>, '...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'root': FieldInfo(annotation=Union[EmptyResult,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ServerResult", validat...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (root: 'RootModelRootType' = PydanticUndefi...
     |  
     |  mmooddeell__ccoonnffiigg = {}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.root_model.RootModel:
     |  
     |  ____iinniitt__ssuubbccllaassss____(**kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
     |  
     |  mmooddeell__ccoonnssttrruucctt(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Create a new model using the provided root object and update fields set.
     |      
     |      Args:
     |          root: The root object of the model.
     |          _fields_set: The set of fields to be updated.
     |      
     |      Returns:
     |          The new model.
     |      
     |      Raises:
     |          NotImplemented: If the model is not a subclass of `RootModel`.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.root_model.RootModel:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.root_model.RootModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____ = None
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'root': FieldInfo(annotation=Union[EmptyResult, Initia...
    
    class SSeettLLeevveellRReeqquueesstt(Request[SetLevelRequestParams, Literal['logging/setLevel']])
     |  SetLevelRequest(*, method: Literal['logging/setLevel'], params: mcp.types.SetLevelRequestParams, **extra_data: Any) -> None
     |  
     |  A request from the client to the server, to enable or adjust logging.
     |  
     |  Method resolution order:
     |      SetLevelRequest
     |      Request[SetLevelRequestParams, Literal['logging/setLevel']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['logging/setLevel'], 'para...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SetLevelRequest'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['logging...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SetLevelRequest", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['logging/setLevel...etL...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['logging/setLev...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class SSeettLLeevveellRReeqquueessttPPaarraammss(RequestParams)
     |  SetLevelRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, level: Literal['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency'], **extra_data: Any) -> None
     |  
     |  Parameters for setting the logging level.
     |  
     |  Method resolution order:
     |      SetLevelRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'level': typing.Literal['debug', 'info', 'notice', ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SetLevelRequestPa...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'level': FieldInfo(annotation=Literal['debug', ...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SetLevelRequestParams"...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me...ale...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'level': FieldInfo(annotation=Literal['debug', 'info',...
    
    class SSuubbssccrriibbeeRReeqquueesstt(Request[SubscribeRequestParams, Literal['resources/subscribe']])
     |  SubscribeRequest(*, method: Literal['resources/subscribe'], params: mcp.types.SubscribeRequestParams, **extra_data: Any) -> None
     |  
     |  Sent from the client to request resources/updated notifications from the server
     |  whenever a particular resource changes.
     |  
     |  Method resolution order:
     |      SubscribeRequest
     |      Request[SubscribeRequestParams, Literal['resources/subscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['resources/subscribe'], 'p...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SubscribeRequest'...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SubscribeRequest", val...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/subscr...bsc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/subs...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class SSuubbssccrriibbeeRReeqquueessttPPaarraammss(RequestParams)
     |  SubscribeRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], **extra_data: Any) -> None
     |  
     |  Parameters for subscribing to a resource.
     |  
     |  Method resolution order:
     |      SubscribeRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'uri': typing.Annotated[pydantic.networks.AnyUrl, U...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.SubscribeRequestP...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[RequestParam...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="SubscribeRequestParams...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me... de...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[RequestParams.Meta,...
    
    class TTeexxttCCoonntteenntt(pydantic.main.BaseModel)
     |  TextContent(*, type: Literal['text'], text: str, annotations: mcp.types.Annotations | None = None, **extra_data: Any) -> None
     |  
     |  Text content for a message.
     |  
     |  Method resolution order:
     |      TextContent
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.Annotations | None, 'text'...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.TextContent'>, 'c...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[Annot...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="TextContent", validato...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, type: Literal['text'], text: str,...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[Annotations,...
    
    class TTeexxttRReessoouurrcceeCCoonntteennttss(ResourceContents)
     |  TextResourceContents(*, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], mimeType: str | None = None, text: str, **extra_data: Any) -> None
     |  
     |  Text contents of a resource.
     |  
     |  Method resolution order:
     |      TextResourceContents
     |      ResourceContents
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'text': <class 'str'>}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.TextResourceConte...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'mimeType': FieldInfo(annotation=Union[str, Non...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="TextResourceContents",...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, uri: typing.Annotated[pydantic.ne...ne ...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ResourceContents:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'mimeType': FieldInfo(annotation=Union[str, NoneType],...
    
    class TTooooll(pydantic.main.BaseModel)
     |  Tool(*, name: str, description: str | None = None, inputSchema: dict[str, typing.Any], annotations: mcp.types.ToolAnnotations | None = None, **extra_data: Any) -> None
     |  
     |  Definition for a tool the client can call.
     |  
     |  Method resolution order:
     |      Tool
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'annotations': mcp.types.ToolAnnotations | None, 'd...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.Tool'>, 'config':...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'annotations': FieldInfo(annotation=Union[ToolA...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="Tool", validator=Model...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, name: str, description: str | Non...ati...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'annotations': FieldInfo(annotation=Union[ToolAnnotati...
    
    class TToooollAAnnnnoottaattiioonnss(pydantic.main.BaseModel)
     |  ToolAnnotations(*, title: str | None = None, readOnlyHint: bool | None = None, destructiveHint: bool | None = None, idempotentHint: bool | None = None, openWorldHint: bool | None = None, **extra_data: Any) -> None
     |  
     |  Additional properties describing a Tool to clients.
     |  
     |  NOTE: all properties in ToolAnnotations are **hints**.
     |  They are not guaranteed to provide a faithful description of
     |  tool behavior (including descriptive properties like `title`).
     |  
     |  Clients should never make tool use decisions based on ToolAnnotations
     |  received from untrusted servers.
     |  
     |  Method resolution order:
     |      ToolAnnotations
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'destructiveHint': bool | None, 'idempotentHint': b...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ToolAnnotations'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'destructiveHint': FieldInfo(annotation=Union[b...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ToolAnnotations", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, title: str | None = None, readOnl...: b...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'destructiveHint': FieldInfo(annotation=Union[bool, No...
    
    class TToooollLLiissttCChhaannggeeddNNoottiiffiiccaattiioonn(Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']])
     |  ToolListChangedNotification(*, method: Literal['notifications/tools/list_changed'], params: mcp.types.NotificationParams | None = None, **extra_data: Any) -> None
     |  
     |  An optional notification from the server to the client, informing it that the list
     |  of tools it offers has changed.
     |  
     |  Method resolution order:
     |      ToolListChangedNotification
     |      Notification[Union[NotificationParams, NoneType], Literal['notifications/tools/list_changed']]
     |      Notification
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['notifications/tools/list_...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ToolListChangedNo...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['notific...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ToolListChangedNotific...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['notifications/to...Par...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Notification:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Notification:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~N...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['notifications/...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class TToooollssCCaappaabbiilliittyy(pydantic.main.BaseModel)
     |  ToolsCapability(*, listChanged: bool | None = None, **extra_data: Any) -> None
     |  
     |  Capability for tools operations.
     |  
     |  Method resolution order:
     |      ToolsCapability
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'listChanged': bool | None}
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.ToolsCapability'>...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'listChanged': FieldInfo(annotation=Union[bool,...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="ToolsCapability", vali...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, listChanged: bool | None = None, **extr...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'listChanged': FieldInfo(annotation=Union[bool, NoneTy...
    
    class UUnnssuubbssccrriibbeeRReeqquueesstt(Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']])
     |  UnsubscribeRequest(*, method: Literal['resources/unsubscribe'], params: mcp.types.UnsubscribeRequestParams, **extra_data: Any) -> None
     |  
     |  Sent from the client to request cancellation of resources/updated notifications from
     |  the server.
     |  
     |  Method resolution order:
     |      UnsubscribeRequest
     |      Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]
     |      Request
     |      pydantic.main.BaseModel
     |      typing.Generic
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'method': typing.Literal['resources/unsubscribe'], ...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____ppaarraammeetteerrss____ = ()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.UnsubscribeReques...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'method': FieldInfo(annotation=Literal['resourc...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="UnsubscribeRequest", v...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, method: Literal['resources/unsubs...bsc...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Request:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Request:
     |  
     |  ____oorriigg__bbaasseess____ = (<class 'pydantic.main.BaseModel'>, typing.Generic[~R...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'method': FieldInfo(annotation=Literal['resources/unsu...
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from typing.Generic:
     |  
     |  ____iinniitt__ssuubbccllaassss____(*args, **kwargs) from pydantic._internal._model_construction.ModelMetaclass
     |      This method is called when a class is subclassed.
     |      
     |      The default implementation does nothing. It may be
     |      overridden to extend subclasses.
    
    class UUnnssuubbssccrriibbeeRReeqquueessttPPaarraammss(RequestParams)
     |  UnsubscribeRequestParams(*, _meta: mcp.types.RequestParams.Meta | None = None, uri: typing.Annotated[pydantic.networks.AnyUrl, UrlConstraints(max_length=None, allowed_schemes=None, host_required=False, default_host=None, default_port=None, default_path=None)], **extra_data: Any) -> None
     |  
     |  Parameters for unsubscribing from a resource.
     |  
     |  Method resolution order:
     |      UnsubscribeRequestParams
     |      RequestParams
     |      pydantic.main.BaseModel
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____aabbssttrraaccttmmeetthhooddss____ = frozenset()
     |  
     |  ____aannnnoottaattiioonnss____ = {'uri': typing.Annotated[pydantic.networks.AnyUrl, U...
     |  
     |  ____ccllaassss__vvaarrss____ = set()
     |  
     |  ____pprriivvaattee__aattttrriibbuutteess____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoommpplleettee____ = True
     |  
     |  ____ppyyddaannttiicc__ccoommppuutteedd__ffiieellddss____ = {}
     |  
     |  ____ppyyddaannttiicc__ccoorree__sscchheemmaa____ = {'cls': <class 'mcp.types.UnsubscribeReques...
     |  
     |  ____ppyyddaannttiicc__ccuussttoomm__iinniitt____ = False
     |  
     |  ____ppyyddaannttiicc__ddeeccoorraattoorrss____ = DecoratorInfos(validators={}, field_validato...
     |  
     |  ____ppyyddaannttiicc__ffiieellddss____ = {'meta': FieldInfo(annotation=Union[RequestParam...
     |  
     |  ____ppyyddaannttiicc__ggeenneerriicc__mmeettaaddaattaa____ = {'args': (), 'origin': None, 'paramete...
     |  
     |  ____ppyyddaannttiicc__ppaarreenntt__nnaammeessppaaccee____ = None
     |  
     |  ____ppyyddaannttiicc__ppoosstt__iinniitt____ = None
     |  
     |  ____ppyyddaannttiicc__sseerriiaalliizzeerr____ = SchemaSerializer(serializer=Model(
     |      Model...
     |  
     |  ____ppyyddaannttiicc__sseettaattttrr__hhaannddlleerrss____ = {}
     |  
     |  ____ppyyddaannttiicc__vvaalliiddaattoorr____ = SchemaValidator(title="UnsubscribeRequestPara...
     |  
     |  ____ssiiggnnaattuurree____ = <Signature (*, _meta: mcp.types.RequestParams.Me... de...
     |  
     |  mmooddeell__ccoonnffiigg = {'extra': 'allow'}
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from RequestParams:
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from RequestParams:
     |  
     |  MMeettaa = <class 'mcp.types.RequestParams.Meta'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccooppyy____(self) -> 'Self'
     |      Returns a shallow copy of the model.
     |  
     |  ____ddeeeeppccooppyy____(self, memo: 'dict[int, Any] | None' = None) -> 'Self'
     |      Returns a deep copy of the model.
     |  
     |  ____ddeellaattttrr____(self, item: 'str') -> 'Any'
     |      Implement delattr(self, name).
     |  
     |  ____eeqq____(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  ____ggeettaattttrr____(self, item: 'str') -> 'Any'
     |  
     |  ____ggeettssttaattee____(self) -> 'dict[Any, Any]'
     |  
     |  ____iinniitt____(self, /, **data: 'Any') -> 'None'
     |      Create a new model by parsing and validating input data from keyword arguments.
     |      
     |      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
     |      validated to form a valid model.
     |      
     |      `self` is explicitly positional-only to allow `self` as a field name.
     |  
     |  ____iitteerr____(self) -> 'TupleGenerator'
     |      So `dict(model)` works.
     |  
     |  ____pprreettttyy____(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'
     |      Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.
     |  
     |  ____rreeppllaaccee____(self, **changes: 'Any') -> 'Self'
     |      # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by
     |      # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:
     |  
     |  ____rreepprr____(self) -> 'str'
     |      Return repr(self).
     |  
     |  ____rreepprr__aarrggss____(self) -> '_repr.ReprArgs'
     |  
     |  ____rreepprr__nnaammee____(self) -> 'str'
     |      Name of the instance's class, used in __repr__.
     |  
     |  ____rreepprr__rreeccuurrssiioonn____(self, object: 'Any') -> 'str'
     |      Returns the string representation of a recursive object.
     |  
     |  ____rreepprr__ssttrr____(self, join_str: 'str') -> 'str'
     |  
     |  ____rriicchh__rreepprr____(self) -> 'RichReprResult'
     |      Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.
     |  
     |  ____sseettaattttrr____(self, name: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  ____sseettssttaattee____(self, state: 'dict[Any, Any]') -> 'None'
     |  
     |  ____ssttrr____(self) -> 'str'
     |      Return str(self).
     |  
     |  ccooppyy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      Returns a copy of the model.
     |      
     |      !!! warning "Deprecated"
     |          This method is now deprecated; use `model_copy` instead.
     |      
     |      If you need `include` or `exclude`, use:
     |      
     |      ```python {test="skip" lint="skip"}
     |      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
     |      data = {**data, **(update or {})}
     |      copied = self.model_validate(data)
     |      ```
     |      
     |      Args:
     |          include: Optional set or mapping specifying which fields to include in the copied model.
     |          exclude: Optional set or mapping specifying which fields to exclude in the copied model.
     |          update: Optional dictionary of field-value pairs to override field values in the copied model.
     |          deep: If True, the values of fields that are Pydantic models will be deep-copied.
     |      
     |      Returns:
     |          A copy of the model with included, excluded and updated fields as specified.
     |  
     |  ddiicctt(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
     |  
     |  jjssoonn(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
     |  
     |  mmooddeell__ccooppyy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
     |      !!! abstract "Usage Documentation"
     |          [`model_copy`](../concepts/serialization.md#model_copy)
     |      
     |      Returns a copy of the model.
     |      
     |      !!! note
     |          The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
     |          might have unexpected side effects if you store anything in it, on top of the model
     |          fields (e.g. the value of [cached properties][functools.cached_property]).
     |      
     |      Args:
     |          update: Values to change/add in the new model. Note: the data is not validated
     |              before creating the new model. You should trust this data.
     |          deep: Set to `True` to make a deep copy of the model.
     |      
     |      Returns:
     |          New model instance.
     |  
     |  mmooddeell__dduummpp(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump`](../concepts/serialization.md#modelmodel_dump)
     |      
     |      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
     |      
     |      Args:
     |          mode: The mode in which `to_python` should run.
     |              If mode is 'json', the output will only contain JSON serializable types.
     |              If mode is 'python', the output may contain non-JSON-serializable Python objects.
     |          include: A set of fields to include in the output.
     |          exclude: A set of fields to exclude from the output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to use the field's alias in the dictionary key if defined.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A dictionary representation of the model.
     |  
     |  mmooddeell__dduummpp__jjssoonn(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
     |      !!! abstract "Usage Documentation"
     |          [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)
     |      
     |      Generates a JSON representation of the model using Pydantic's `to_json` method.
     |      
     |      Args:
     |          indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
     |          include: Field(s) to include in the JSON output.
     |          exclude: Field(s) to exclude from the JSON output.
     |          context: Additional context to pass to the serializer.
     |          by_alias: Whether to serialize using field aliases.
     |          exclude_unset: Whether to exclude fields that have not been explicitly set.
     |          exclude_defaults: Whether to exclude fields that are set to their default value.
     |          exclude_none: Whether to exclude fields that have a value of `None`.
     |          round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
     |          warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
     |              "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
     |          fallback: A function to call when an unknown value is encountered. If not provided,
     |              a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
     |          serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
     |      
     |      Returns:
     |          A JSON string representation of the model.
     |  
     |  mmooddeell__ppoosstt__iinniitt(self, context: 'Any', /) -> 'None'
     |      Override this method to perform additional initialization after `__init__` and `model_construct`.
     |      This is useful if you want to do some validation that requires the entire model to be initialized.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from pydantic.main.BaseModel:
     |  
     |  ____ccllaassss__ggeettiitteemm____(typevar_values: 'type[Any] | tuple[type[Any], ...]') -> 'type[BaseModel] | _forward_ref.PydanticRecursiveRef' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__ccoorree__sscchheemmaa____(source: 'type[BaseModel]', handler: 'GetCoreSchemaHandler', /) -> 'CoreSchema' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ____ggeett__ppyyddaannttiicc__jjssoonn__sscchheemmaa____(core_schema: 'CoreSchema', handler: 'GetJsonSchemaHandler', /) -> 'JsonSchemaValue' from pydantic._internal._model_construction.ModelMetaclass
     |      Hook into generating the model's JSON schema.
     |      
     |      Args:
     |          core_schema: A `pydantic-core` CoreSchema.
     |              You can ignore this argument and call the handler with a new CoreSchema,
     |              wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
     |              or just call the handler with the original schema.
     |          handler: Call into Pydantic's internal JSON schema generation.
     |              This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
     |              generation fails.
     |              Since this gets called by `BaseModel.model_json_schema` you can override the
     |              `schema_generator` argument to that function to change JSON schema generation globally
     |              for a type.
     |      
     |      Returns:
     |          A JSON schema, as a Python object.
     |  
     |  ____ppyyddaannttiicc__iinniitt__ssuubbccllaassss____(**kwargs: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |      This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
     |      only after the class is actually fully initialized. In particular, attributes like `model_fields` will
     |      be present when this is called.
     |      
     |      This is necessary because `__init_subclass__` will always be called by `type.__new__`,
     |      and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
     |      `type.__new__` was called in such a manner that the class would already be sufficiently initialized.
     |      
     |      This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
     |      any kwargs passed to the class definition that aren't used internally by pydantic.
     |      
     |      Args:
     |          **kwargs: Any keyword arguments passed to the class definition that aren't used internally
     |              by pydantic.
     |  
     |  ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ffrroomm__oorrmm(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  mmooddeell__ccoonnssttrruucctt(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Creates a new instance of the `Model` class with validated data.
     |      
     |      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
     |      Default values are respected, but no other validation is performed.
     |      
     |      !!! note
     |          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
     |          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
     |          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
     |          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
     |          an error if extra values are passed, but they will be ignored.
     |      
     |      Args:
     |          _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
     |              this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
     |              Otherwise, the field names from the `values` argument will be used.
     |          values: Trusted or pre-validated data dictionary.
     |      
     |      Returns:
     |          A new instance of the `Model` class with validated data.
     |  
     |  mmooddeell__jjssoonn__sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |      Generates a JSON schema for a model class.
     |      
     |      Args:
     |          by_alias: Whether to use attribute aliases or not.
     |          ref_template: The reference template.
     |          schema_generator: To override the logic used to generate the JSON schema, as a subclass of
     |              `GenerateJsonSchema` with your desired modifications
     |          mode: The mode in which to generate the schema.
     |      
     |      Returns:
     |          The JSON schema for the given model class.
     |  
     |  mmooddeell__ppaarraammeettrriizzeedd__nnaammee(params: 'tuple[type[Any], ...]') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |      Compute the class name for parametrizations of generic classes.
     |      
     |      This method can be overridden to achieve a custom naming scheme for generic BaseModels.
     |      
     |      Args:
     |          params: Tuple of types of the class. Given a generic class
     |              `Model` with 2 type variables and a concrete model `Model[str, int]`,
     |              the value `(str, int)` would be passed to `params`.
     |      
     |      Returns:
     |          String representing the new class where `params` are passed to `cls` as type variables.
     |      
     |      Raises:
     |          TypeError: Raised when trying to generate concrete names for non-generic models.
     |  
     |  mmooddeell__rreebbuuiilldd(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None' from pydantic._internal._model_construction.ModelMetaclass
     |      Try to rebuild the pydantic-core schema for the model.
     |      
     |      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
     |      the initial attempt to build the schema, and automatic rebuilding fails.
     |      
     |      Args:
     |          force: Whether to force the rebuilding of the model schema, defaults to `False`.
     |          raise_errors: Whether to raise errors, defaults to `True`.
     |          _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
     |          _types_namespace: The types namespace, defaults to `None`.
     |      
     |      Returns:
     |          Returns `None` if the schema is already "complete" and rebuilding was not required.
     |          If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
     |  
     |  mmooddeell__vvaalliiddaattee(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate a pydantic model instance.
     |      
     |      Args:
     |          obj: The object to validate.
     |          strict: Whether to enforce types strictly.
     |          from_attributes: Whether to extract data from object attributes.
     |          context: Additional context to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Raises:
     |          ValidationError: If the object could not be validated.
     |      
     |      Returns:
     |          The validated model instance.
     |  
     |  mmooddeell__vvaalliiddaattee__jjssoonn(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      !!! abstract "Usage Documentation"
     |          [JSON Parsing](../concepts/json.md#json-parsing)
     |      
     |      Validate the given JSON data against the Pydantic model.
     |      
     |      Args:
     |          json_data: The JSON data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |      
     |      Raises:
     |          ValidationError: If `json_data` is not a JSON string or the object could not be validated.
     |  
     |  mmooddeell__vvaalliiddaattee__ssttrriinnggss(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |      Validate the given object with string data against the Pydantic model.
     |      
     |      Args:
     |          obj: The object containing string data to validate.
     |          strict: Whether to enforce types strictly.
     |          context: Extra variables to pass to the validator.
     |          by_alias: Whether to use the field's alias when validating against the provided input data.
     |          by_name: Whether to use the field's name when validating against the provided input data.
     |      
     |      Returns:
     |          The validated Pydantic model.
     |  
     |  ppaarrssee__ffiillee(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__oobbjj(obj: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ppaarrssee__rraaww(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  sscchheemmaa__jjssoonn(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  uuppddaattee__ffoorrwwaarrdd__rreeffss(**localns: 'Any') -> 'None' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  vvaalliiddaattee(value: 'Any') -> 'Self' from pydantic._internal._model_construction.ModelMetaclass
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from pydantic.main.BaseModel:
     |  
     |  ____ffiieellddss__sseett____
     |  
     |  mmooddeell__eexxttrraa
     |      Get extra fields set during validation.
     |      
     |      Returns:
     |          A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
     |  
     |  mmooddeell__ffiieellddss__sseett
     |      Returns the set of fields that have been explicitly set on this model instance.
     |      
     |      Returns:
     |          A set of strings representing the fields that have been set,
     |              i.e. that were not filled from defaults.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pydantic.main.BaseModel:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____ppyyddaannttiicc__eexxttrraa____
     |  
     |  ____ppyyddaannttiicc__ffiieellddss__sseett____
     |  
     |  ____ppyyddaannttiicc__pprriivvaattee____
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pydantic.main.BaseModel:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____ppyyddaannttiicc__rroooott__mmooddeell____ = False
     |  
     |  mmooddeell__ccoommppuutteedd__ffiieellddss = {}
     |  
     |  mmooddeell__ffiieellddss = {'meta': FieldInfo(annotation=Union[RequestParams.Meta,...

DDAATTAA
    AAnnyy = typing.Any
        Special type indicating an unconstrained type.
        
        - Any is compatible with every type.
        - Any assumed to have all methods.
        - All values assumed to be instances of Any.
        
        Note that all the above statements are true from the point of view of
        static type checkers. At runtime, Any should not be used with instance
        or class checks.
    
    AAnnyyFFuunnccttiioonn = collections.abc.Callable[..., typing.Any]
    CCOONNNNEECCTTIIOONN__CCLLOOSSEEDD = -32000
    CCoonntteenntt = mcp.types.TextContent | mcp.types.ImageContent | mcp.types.A...
    IINNTTEERRNNAALL__EERRRROORR = -32603
    IINNVVAALLIIDD__PPAARRAAMMSS = -32602
    IINNVVAALLIIDD__RREEQQUUEESSTT = -32600
    IInncclluuddeeCCoonntteexxtt = typing.Literal['none', 'thisServer', 'allServers']
    LLAATTEESSTT__PPRROOTTOOCCOOLL__VVEERRSSIIOONN = '2025-03-26'
    LLiitteerraall = typing.Literal
        Special typing form to define literal types (a.k.a. value types).
        
        This form can be used to indicate to type checkers that the corresponding
        variable or function parameter has a value equivalent to the provided
        literal (or one of several literals):
        
          def validate_simple(data: Any) -> Literal[True]:  # always returns True
              ...
        
          MODE = Literal['r', 'rb', 'w', 'wb']
          def open_helper(file: str, mode: MODE) -> str:
              ...
        
          open_helper('/some/path', 'r')  # Passes type check
          open_helper('/other/path', 'typo')  # Error in type checker
        
        Literal[...] cannot be subclassed. At runtime, an arbitrary value
        is allowed as type argument to Literal[...], but type checkers may
        impose restrictions.
    
    LLooggggiinnggLLeevveell = typing.Literal['debug', 'info', 'notice', 'warning', 'e...
    MMEETTHHOODD__NNOOTT__FFOOUUNNDD = -32601
    MMeetthhooddTT = ~MethodT
    NNoottiiffiiccaattiioonnPPaarraammssTT = ~NotificationParamsT
    PPAARRSSEE__EERRRROORR = -32700
    PPrrooggrreessssTTookkeenn = str | int
    RReeqquueessttIIdd = typing.Annotated[int | str, FieldInfo(annotation...ticGene...
    RReeqquueessttPPaarraammssTT = ~RequestParamsT
    RRoollee = typing.Literal['user', 'assistant']
    SSttooppRReeaassoonn = typing.Union[typing.Literal['endTurn', 'stopSequence', 'm...
    TTyyppeeAAlliiaass = typing.TypeAlias
        Special marker indicating that an assignment should
        be recognized as a proper type alias definition by type
        checkers.
        
        For example::
        
            Predicate: TypeAlias = Callable[..., bool]
        
        It's invalid when used anywhere except as in the example above.
    
    ____aannnnoottaattiioonnss____ = {'AnyFunction': typing.TypeAlias}

FFIILLEE
    /home/revati/Bakery_MCP/venv/lib/python3.10/site-packages/mcp/types.py

